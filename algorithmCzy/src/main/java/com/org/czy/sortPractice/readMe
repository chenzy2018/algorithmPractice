排序稳定性：
    排序之前的相对关系如果非常重要，就需要稳定的排序算法

    冒泡排序：不稳定(可以实现，遇到相等，就让相等的后面那个值继续执行冒泡流程)
    选择排序：不稳定，找到后面最小值和当前位置交换
    插入排序：不稳定(可以实现，相等就不往前插入)

    归并排序：稳定(可以稳定，merge的时候，相等先拷贝左边的)
    快速排序：不稳定(用来作为左右划分的值是不能保证稳定，不过也可以做到，非常难 01 stable sort)
    堆排序：不稳定(构建初始堆的时候不会考虑相等值)

    面试题：基于01 stable sort
        给定一个数组，把奇数放左边，把偶数放右边，且保证稳定性，空间复杂度O(1),时间复杂度O(n)
        如果这个能解决，那快排就可以做到稳定性，因为都01问题(奇偶，大于和小于等于都是要么是1要么是0的01问题)，可以反怼面试官

    工作中排序是混合使用的：
        1.给定的数组中全是基础类型(int等)，使用快排，因为不需要稳定性
            然后当数组数量比较少(小于60)，会直接使用插入排序
        2.给定的数组是自定义的bean，使用归并，因为需要考虑稳定性
            然后当数组数量比较少(小于60)，会直接使用插入排序

桶排序：一个概念，不基于比较的排序方式，稳定的，跟数据状态有关系，一般很少用 O(n)
    计数排序：桶排序的具体实现
        遍历数据，记录数字出现的次数(相当于把相同的数字放到一个桶里)，然后再根据记录恢复数组
    基数排序：桶排序的具体实现
        桶用的比较精致，只需要10个桶(0到9)，根据个位数先排，再根据十位数排，一直排到最高位